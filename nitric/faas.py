#
# Copyright (c) 2021 Nitric Technologies Pty Ltd.
#
# This file is part of Nitric Python 3 SDK.
# See https://github.com/nitrictech/python-sdk for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
from __future__ import annotations

import inspect
from enum import Enum

import functools
import json

from typing import Dict, Generic, Protocol, Union, List, TypeVar, Any, Optional
from opentelemetry import propagate

from abc import ABC, abstractmethod

from nitric.proto.apis.v1 import (
    ClientMessage as ApiClientMessage,
    ServerMessage as ApiServerMessage,
    HttpResponse as ApiResponse,
)
from nitric.proto.schedules.v1 import (
    ClientMessage as ScheduleClientMessage,
    ServerMessage as ScheduleServerMessage,
)
from nitric.proto.storage.v1 import (
    ClientMessage as BucketNotificationClientMessage,
    BlobEventType,
)
from nitric.proto.topics.v1 import (
    ClientMessage as TopicClientMessage,
    ServerMessage as TopicServerMessage,
    MessageResponse as TopicResponse,
)
from nitric.proto.websockets.v1 import (
    ServerMessage as WebsocketServerMessage,
    WebsocketEventResponse,
)

Record = Dict[str, Union[str, List[str]]]
PROPAGATOR = propagate.get_global_textmap()


class HttpMethod(Enum):
    """Valid query expression operators."""

    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"
    OPTIONS = "OPTIONS"

    def __str__(self):
        return str(self.value)


class Request(ABC):
    """Represents an abstract trigger request."""

    def __init__(self, data: bytes, trace_context: Dict[str, str]):
        """Construct a new Request."""
        self.data = data
        self.trace_context = trace_context


class Response(ABC):
    """Represents an abstract trigger response."""

    pass


class TriggerContext(Protocol):
    """Represents an abstract request/response context for any trigger."""

    @staticmethod
    def from_request(server_message) -> TriggerContext:
        """Convert a server message request into this trigger context."""
        pass

    def to_response(self):
        """Convert this trigger context into a server message response."""
        pass


# ====== HTTP ======


class HttpRequest(Request):
    """Represents a translated Http Request forwarded from the Nitric Membrane."""

    def __init__(
        self,
        data: bytes,
        method: str,
        path: str,
        params: Dict[str, str],
        query: Record,
        headers: Record,
        trace_context: Dict[str, str],
    ):
        """Construct a new HttpRequest."""
        super().__init__(data, trace_context)
        self.method = method
        self.path = path
        self.params = params
        self.query = query
        self.headers = headers

    @property
    def json(self) -> Optional[Any]:
        """Get the body of the request as JSON, returns None if request body is not JSON."""
        try:
            return json.loads(self.body)
        except json.JSONDecodeError:
            return None
        except TypeError:
            return None

    @property
    def body(self):
        """Get the body of the request as text."""
        return self.data.decode("utf-8")


class HttpResponse(Response):
    """Represents an HTTP Response to be generated by the Nitric Membrane in response to an HTTP Request Trigger."""

    def __init__(self, status: int = 200, headers: Optional[Record] = None, body: Optional[bytes] = None):
        """Construct a new HttpResponse."""
        self.status = status
        self.headers = headers if headers else {}
        self._body = body if body else bytes()

    @property
    def body(self):
        """Return the HTTP response body."""
        return self._body

    @body.setter
    def body(self, value: Union[str, bytes, Any]):
        if isinstance(value, str):
            self._body = value.encode("utf-8")
        elif isinstance(value, bytes):
            self._body = value
        else:
            self._body = json.dumps(value).encode("utf-8")
            self.headers["Content-Type"] = ["application/json"]


class HttpContext:
    """Represents the full request/response context for an Http based trigger."""

    def __init__(self, request: HttpRequest, response: Optional[HttpResponse] = None):
        """Construct a new HttpContext."""
        self.req = request
        self.res = response if response else HttpResponse()

    @staticmethod
    def from_request(msg: ApiServerMessage) -> HttpContext:
        """Construct a new HttpContext from an Http trigger from the Nitric Membrane."""
        headers: Record = {k: v.value for (k, v) in msg.http_request.headers.items()}
        query: Record = {k: v.value for (k, v) in msg.http_request.query_params.items()}

        return HttpContext(
            request=HttpRequest(
                data=msg.data,
                method=msg.http_request.method,
                query=query,
                path=msg.http_request.path,
                params={k: v for (k, v) in msg.http_request.path_params.items()},
                headers=headers,
                trace_context=msg.trace_context.values,
            )
        )

    def to_response(self) -> ApiClientMessage:
        """Construct a HttpResponse for the Nitric Membrane from this context object."""
        headers = {k: HttpContext._ensure_value_is_list(v) for (k, v) in self.res.headers.items()}
        body = self.res.body if self.res.body else bytes()

        resp = ApiResponse(
            status=self.res.status,
            body=body,
            headers=headers,
        )

        return ApiClientMessage(http_response=resp)

    @staticmethod
    def _ensure_value_is_list(value: Union[str, List[str]]) -> List[str]:
        return list(value) if isinstance(value, list) else [value]


class EventRequest(Request):
    """Represents a translated Event, from a Subscribed Topic, forwarded from the Nitric Membrane."""

    def __init__(self, data: bytes, topic: str, trace_context: Dict[str, str]):
        """Construct a new EventRequest."""
        super().__init__(data, trace_context)
        self.topic = topic

    @property
    def payload(self) -> Any:
        """Return the payload of this event, usually a dictionary."""
        event_envelope = json.loads(self.data.decode("utf-8"))
        return event_envelope["payload"] if isinstance(event_envelope, dict) else event_envelope


class EventResponse(Response):
    """Represents the response to a trigger from an Event as a result of a Topic subscription."""

    def __init__(self, success: bool = True):
        """Construct a new EventResponse."""
        self.success = success


class EventContext:
    """Represents the full request/response context for an Event based trigger."""

    def __init__(self, request: EventRequest, response: Optional[EventResponse] = None):
        """Construct a new EventContext."""
        self.req = request
        self.res = response if response else EventResponse()

    @staticmethod
    def from_request(msg: TopicServerMessage) -> EventContext:
        """Construct a new EventContext from a Topic trigger from the Nitric Membrane."""
        data = msg.message_request.message.struct_payload.to_json()

        return EventContext(
            request=EventRequest(
                data=bytes(data),
                topic=msg.message_request.topic,
                trace_context=msg.trace_context.values,
            )
        )

    def to_response(self) -> TopicClientMessage:
        """Construct a EventContext for the Nitric Membrane from this context object."""
        return TopicClientMessage(message_response=TopicResponse(success=self.res.success))


# == WEBSOCKET ==


class WebsocketRequest:
    """Represents an incoming websocket event."""

    def __init__(
        self, connection_id: str, data: bytes, query: Dict[str, str | List[str]], trace_context: Dict[str, str]
    ):
        """Construct a new WebsocketRequest."""
        super().__init__(data, trace_context)

        self.connection_id = connection_id
        self.query = query


class WebsocketResponse(Response):
    """Represents a response to a websocket event."""

    def __init__(self, success: bool = True):
        """Construct a new WebsocketResponse."""
        self.success = success


class WebsocketContext:
    """Represents the full request/response context for a Websocket based trigger."""

    def __init__(self, request: WebsocketRequest, response: Optional[WebsocketResponse] = None):
        """Construct a new WebsocketContext."""
        self.req = request
        self.res = response if response else WebsocketResponse()

    @staticmethod
    def from_request(msg: WebsocketServerMessage) -> WebsocketContext:
        """Construct a new WebsocketContext from a Websocket trigger from the Nitric Membrane."""
        query: Record = {k: v.value for (k, v) in msg.websocket_event_request.query_params.items()}
        return WebsocketContext(
            request=WebsocketRequest(
                data=msg,
                connection_id=msg.websocket_event_request.connection_id,
                query=query,
                trace_context=msg.trace_context.values,
            )
        )

    def to_response(self) -> WebsocketEventResponse:
        """Construct a WebsocketContext for the Nitric Membrane from this context object."""
        return WebsocketEventResponse()


class BucketNotificationRequest(Request):
    """Represents a translated Event, from a subscribed bucket notification, forwarded from the Nitric Membrane."""

    def __init__(self, data: bytes, key: str, notification_type: BlobEventType, trace_context: Dict[str, str]):
        """Construct a new EventRequest."""
        super().__init__(data, trace_context)

        self.key = key
        self.notification_type = notification_type


class BucketNotificationResponse(Response):
    """Represents the response to a trigger from a Bucket."""

    def __init__(self, success: bool = True):
        """Construct a new BucketNotificationResponse."""
        self.success = success


class BucketNotificationContext:
    """Represents the full request/response context for a bucket notification trigger."""

    def __init__(self, request: BucketNotificationRequest, response: Optional[BucketNotificationResponse] = None):
        """Construct a new BucketNotificationContext."""
        self.req = request
        self.res = response if response else BucketNotificationResponse()

    @staticmethod
    def from_client_message(client_message: BucketNotificationClientMessage) -> BucketNotificationContext:
        """Construct a new BucketNotificationContext from a Bucket Notification trigger from the Nitric Membrane."""
        return BucketNotificationContext(
            request=BucketNotificationRequest(
                data=client_message.data,
                key=client_message.notification.bucket.key,
                notification_type=client_message.notification.bucket.type,
                trace_context=client_message.trace_context.values,
            )
        )


class FileNotificationRequest(BucketNotificationRequest):
    """Represents a translated Event, from a subscribed bucket notification, forwarded from the Nitric Membrane."""

    def __init__(
        self,
        data: bytes,
        bucket_ref: Any,  # can't import BucketRef due to circular dependency problems
        key: str,
        notification_type: BlobEventType,
        trace_context: Dict[str, str],
    ):
        """Construct a new FileNotificationRequest."""
        super().__init__(data=data, key=key, notification_type=notification_type, trace_context=trace_context)
        self.file = bucket_ref.file(key)


class FileNotificationContext(BucketNotificationContext):
    """Represents the full request/response context for a bucket notification trigger."""

    def __init__(self, request: FileNotificationRequest, response: Optional[BucketNotificationResponse] = None):
        """Construct a new FileNotificationContext."""
        super().__init__(request=request, response=response)
        self.req = request

    @staticmethod
    def from_client_message_with_bucket(
        client_message: BucketNotificationClientMessage, bucket_ref
    ) -> FileNotificationContext:
        """Construct a new FileNotificationTrigger from a Bucket Notification trigger from the Nitric Membrane."""
        return FileNotificationContext(
            request=FileNotificationRequest(
                data=client_message.data,
                key=client_message.notification.bucket.key,
                bucket_ref=bucket_ref,
                notification_type=client_message.notification.bucket.type,
                trace_context=client_message.trace_context.values,
            )
        )


# == Schedules ==


class IntervalRequest(Request):
    """Represents a translated Event, from a Schedule, forwarded from the Nitric Membrane."""

    def __init__(self, data: bytes, schedule_name: str, trace_context: Dict[str, str]):
        """Construct a new IntervalRequest."""
        super().__init__(data, trace_context)
        self.schedule_name = schedule_name

    @property
    def payload(self) -> Any:
        """Return the payload of this event, usually a dictionary."""
        event_envelope = json.loads(self.data.decode("utf-8"))
        return event_envelope["payload"] if isinstance(event_envelope, dict) else event_envelope


class IntervalResponse(Response):
    """Represents the response to a trigger from an Interval as a result of a Schedule."""

    def __init__(self, success: bool = True):
        """Construct a new EventResponse."""
        self.success = success


class IntervalContext:
    """Represents the full request/response context for an Interval based trigger."""

    def __init__(self, request: IntervalRequest, response: Optional[IntervalResponse] = None):
        """Construct a new EventContext."""
        self.req = request
        self.res = response if response else IntervalResponse()

    @staticmethod
    def from_request(msg: ScheduleServerMessage) -> IntervalContext:
        """Construct a new IntervalContext from a Schedule trigger from the Nitric Membrane."""
        return IntervalContext(
            request=IntervalRequest(
                data=msg.data,
                schedule_name=msg.interval_request.schedule_name,
                trace_context=msg.trace_context.values,
            )
        )

    def to_response(self) -> TopicClientMessage:
        """Construct a EventContext for the Nitric Membrane from this context object."""
        return ScheduleClientMessage(interval_response=IntervalResponse(success=self.res.success))


C = TypeVar(
    "C",
    TriggerContext,
    HttpContext,
    EventContext,
    FileNotificationContext,
    BucketNotificationContext,
    WebsocketContext,
    IntervalContext,
)


class Middleware(Protocol, Generic[C]):
    """A middleware function."""

    async def __call__(self, ctx: C, nxt: Optional[Middleware[C]] = None) -> C:
        """Process trigger context."""
        ...


class Handler(Protocol, Generic[C]):
    """A handler function."""

    async def __call__(self, ctx: C) -> C | None:
        """Process trigger context."""
        ...


HttpMiddleware = Middleware[HttpContext]
EventMiddleware = Middleware[EventContext]
IntervalMiddleware = Middleware[IntervalContext]
BucketNotificationMiddleware = Middleware[BucketNotificationContext]
FileNotificationMiddleware = Middleware[FileNotificationContext]
WebsocketMiddleware = Middleware[WebsocketContext]

HttpHandler = Handler[HttpContext]
EventHandler = Handler[EventContext]
IntervalHandler = Handler[IntervalContext]
BucketNotificationHandler = Handler[BucketNotificationContext]
FileNotificationHandler = Handler[FileNotificationContext]
WebsocketHandler = Handler[WebsocketContext]


def _convert_to_middleware(handler: Handler[C] | Middleware[C]) -> Middleware[C]:
    """Convert a handler to a middleware, if it's already a middleware it's returned unchanged."""
    if not _is_handler(handler):
        # it's not a middleware, don't convert it.
        return handler  # type: ignore

    async def middleware(ctx: C, nxt: Middleware[C]) -> C:
        context = await handler(ctx)  # type: ignore
        return await nxt(context) if nxt else context  # type: ignore

    return middleware  # type: ignore


def _is_handler(unknown: Middleware[C] | Handler[C]) -> bool:
    """Return True if the provided function is a handler (1 positional arg)."""
    signature = inspect.signature(unknown)
    params = signature.parameters
    positional = [name for name, param in params.items() if param.default == inspect.Parameter.empty]
    return len(positional) == 1


def compose_middleware(*middlewares: Middleware[C] | Handler[C]) -> Middleware[C]:
    """
    Compose multiple middleware functions into a single middleware function.

    The resulting middleware will effectively be a chain of the provided middleware,
    where each calls the next in the chain when they're successful.
    """
    middlewares = [_convert_to_middleware(middleware) for middleware in middlewares]  # type: ignore

    async def composed(ctx: C, nxt: Optional[Middleware[C]] = None) -> C:
        last_middleware = nxt

        def reduce_chain(acc_next: Middleware[C], cur: Middleware[C]) -> Middleware[C]:
            async def chained_middleware(ctx: C, nxt: Optional[Middleware[C]] = None) -> C:
                result = (await nxt(ctx)) if nxt is not None else ctx  # type: ignore
                # type ignored because mypy appears to misidentify the correct return type
                output_context = await cur(result, acc_next)  # type: ignore
                if not output_context:
                    return result  # type: ignore
                return output_context  # type: ignore

            return chained_middleware

        middleware_chain = functools.reduce(reduce_chain, reversed(middlewares))  # type: ignore
        # type ignored because mypy appears to misidentify the correct return type
        return await middleware_chain(ctx, last_middleware)  # type: ignore

    return composed


class FunctionServer(ABC):
    """Represents a worker that should be started at runtime."""

    @abstractmethod
    def start(self) -> None:
        """Start the worker."""
        pass
